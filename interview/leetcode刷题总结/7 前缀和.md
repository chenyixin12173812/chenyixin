# 前缀和

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)



```java
class Solution {
//https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/
public int subarraySum(int[] nums, int k) {

   return method2(nums,k);

}
// 暴力法
int method1(int[] nums, int k){
    int cunt = 0;
    for(int i=0;i<nums.length;i++){
       int sum =0;
       for(int j =i;j<nums.length;j++){
         sum = sum + nums[j];
         if(sum==k){
             cunt++;
         } 
       }
    } 

         return cunt;

}
int method2(int[] nums, int k){

    int pre = 0;
    int cunt =0;
    Map<Integer,Integer> map = new HashMap<>();
    //[3] [1,-1]
    map.put(0,1);
    for(int i =0;i<nums.length;i++){
       pre = pre + nums[i];
 
       if(map.containsKey(pre-k)){
           cunt  = cunt + map.get(pre-k);
       }
       map.put(pre,map.getOrDefault(pre,0)+1);
    }

     return cunt;
}}
```

#### [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

```java
class Solution {
    int[] dp = new int[10010];
    public boolean checkSubarraySum(int[] nums, int k) {
        if(nums.length < 2) return false;
        //k==0时单独考虑，其实和k!=0时只有做不做模运算的区别
        if(k == 0){
            for(int i = 0; i < nums.length; i++){
                for(int j = 0; j < nums.length-i; j++){
                    dp[j] = (dp[j]+nums[j+i]);
                    if(i != 0 && dp[j] == 0) return true;
                }
            }
        return false;
        }
        //当i=k时，dp[j]表示以j为起始下标，nums中连续k+1个整数的和
        //如当i=0时，相当于将nums拷贝到dp
        //i=1时，dp[0]相当于以0为起始下标，nums中2个整数的和，即nums[0]+nums[1]
        //每次计算时都可以用原来的dp进行更新，而不用一个个去加
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < nums.length-i; j++){
                dp[j] = (dp[j]+nums[j+i]) % k;
                if(i != 0 && dp[j] == 0) return true;
            }
        }
        return false;
    }
}


class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {

      int pre = 0;
      int len = nums.length;
      if(len<2) return false;
      Map<Integer,Integer> map = new HashMap<>();

      map.put(0,-1);
      for(int i=0 ;i<nums.length;i++) {
        pre +=nums[i];
        if(k!=0){
           pre = pre %k; 
        }
        if(map.containsKey(pre)) {
           if(i-map.get(pre)>1){
               return true;
           }

        } else {
              map.put(pre,i);
        }
      } 
      return false;

    }
}



```

## 327. 区间和的个数

给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。
区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

说明:
最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。

示例:

输入: nums = [-2,5,-1], lower = -2, upper = 2,
输出: 3 
解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。




## 1248 题： 统计「优美子数组

## 454 题：四数相加 II