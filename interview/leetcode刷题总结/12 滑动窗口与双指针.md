# 滑动窗口与双指针

# 424 替换后的最长重复字符

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意:
字符串长度 和 k 不会超过 104。

示例 1:

输入:
s = "ABAB", k = 2

输出:
4

解释:
用两个'A'替换为两个'B',反之亦然。
示例 2:

输入:
s = "AABABBA", k = 1

输出:
4

解释:
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。

```java
class Solution {
    public int characterReplacement(String s, int k) {

     char [] temp = s.toCharArray();;
     int len = temp.length;
     int i =0;
     int j =0;
     int max =0;
     int cunt[]= new int [26];
     while(j<len) {
       
      cunt[temp[j]-'A']++;      
      j++;
      if(getDistince(cunt)<=k) {
         max= Math.max(max,j-i);  
      }
       
      while(i<=j &&getDistince(cunt)>k) {
         cunt[temp[i]-'A']--;
         i++; 
      } 
     }

     return max; 
    }

    private int getDistince(int []cunt) {

     int max = cunt[0];
     int sum = cunt[0];

     for(int i = 1;i<26;i++) {
         max = Math.max(max,cunt[i]);
         sum = sum+ cunt[i];
     }
     return sum-max;

    }



}
```

# 713. 乘积小于K的子数

给定一个正整数数组 nums。

找出该数组内乘积小于 k 的连续的子数组的个数。

示例 1:

输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
说明:

0 < nums.length <= 50000
0 < nums[i] < 1000
0 <= k < 10^6

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
    int len = nums.length;
    if(len<2||k<1) {
        return 0;
    }
    int start = 0;
    int end = 0;
    int ans =1;
    int max =0;


    while(end<len) {
       ans = ans*nums[end];
       
       while(start<=end&&ans>=k) {
        ans = ans/nums[start];
        start++;
       }
       max = max+(end -start +1);
       end++;
    }
    return max;
    }
}
```

