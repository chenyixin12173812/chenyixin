

# 1 删除策略方法

先进先出FIFO
最近最少使用LRU
最不经常使用算法LFU，根据在一段时间里页面被使用的次数选择出最少使用的页
最优替换（不能实现）

# 2 redis的数据结构（5种）
String
hash
set
zset
list
list的底层数据实现结构
ziplist或linkedlist
zset的底层数据实现结构
zset底层的存储结构包括ziplist或skiplist，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist，两个条件如下：
有序集合保存的元素数量小于128个
有序集合保存的所有元素的长度小于64字节
hash的底层数据结构
ziplist（压缩列表）和hashtable

# 3 发生雪崩了 

 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。通俗讲就是：缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。

 如何防止：

缓存失效或，通过加锁或队列来控制读取数据库的访问的线程数量，比如对某个key值运行一个线程访问数据库，其他线程等待
不同的key，设置不同的过期时间，让环创失效的时间点尽量均匀
做二级缓存，a1失效时候，访问a2，a1失效的时间设置为短期，a2为长期
按你使用消息队列时候，那就把多线程变成单线程了吗？在高并发时候你觉得这样适用吗？应该怎么处理

# 4  redis 的底层数据结构有哪些

# 5 redis 中的 SDS 和 C 语言中的字符串有什么区别，优点是什么

# 6 redis 中的字典是如何实现的，如何解决冲突和扩容

#  7 redis 的跳表的使用场景是什么

# 8 redis 缓存穿透，缓存击穿，缓存雪崩，热点数据集中失效 
# 9 redis 的持久化方式，RDB 和 AOF 使用场景

# 10 redis 如何处理事务

# 11 redis 是单线程为什么还那么快？

# 12 redis 的操作为什么是原子性的，如何保证原子性

# 13 redis 集群用过哪些方案，分别怎么做。讲一下一致性哈希

# 14 redis 什么情况下会出现性能问题，处理办法？

# 15 redis 的内存模型

# 16 redis 和 memcache 的区别

# 17 你用 redis 做过什么？（这里尽量不要讲只做过缓存，可以说一下队列，排行榜/计数器，发布/订阅）

# 18 你用过哪些非关系型数据库，都有什么特点，使用场景分别是什么（体现你技术广度的时刻到了，尽可能多说，但是不会的不要说，防止被问死）

# 19   Redis 出现雪崩怎么解决？

# 20 如何解决数据一致性问题？

# 21 Redis 的使用场景、高性能的原因？影响带宽的原因？



# 22 丰富的数据类型和数据结构（双端链表、字典、压缩链表、跳表）

​       Redis bitmap、Stream

# 23 压缩链表为什么节约内存

# 24 Redis 缓存如何保证一致性

# 25 rehash

渐进式rehash
以下是哈希表渐进式 rehash 的详细步骤：

为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。
渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量
因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。

另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表

  http://redisbook.com/preview/dict/incremental_rehashing.html 

# 26 redis key 和 value 的最大范围

 

  redis的key和string类型value限制均为512MB 

# 27 tair与redis

# 28 redis 大量缓存需要更新

# 29 RDB文件是如何写入的（copyOnWrite必考）

1 Redis中执行BGSAVE命令生成RDB文件时，本质就是调用Linux中的fork()命令，Linux下的fork()系统调用实现了copy-on-write写时复制；
2 fork()是类Unix操作系统上创建线程的主要方法，fork用于创建子进程（等同于当前进程的副本）；
3 传统的普通进程复制，会直接将父进程的数据拷贝到子进程中，拷贝完成后，父进程和子进程之间的数据段和堆栈是相互独立的；
4 copy-on-write技术，在fork出子进程后，与父进程共享内存空间，两者只是虚拟空间不同，但是其对应的物理空间是同一个；

# 30 rdb 数据丢失？

# 31 RDB copyOnWrite的问题

Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断page-fault)，这样就得耗费不少性能在复制上。
而在rehash阶段上，写操作是无法避免的。所以Redis在fork出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。

 # 32 AOF过程 

后台重写
子进程进行AOF后台重写
1 不阻塞服务器
2使用子进程不是线程，可以避免使用锁的竞争

4.1 如何解决不一致
Redis设置AOF缓存区，当Redis服务器执行完一个命令，同时发送缓存区。



服务端执行以下3个工作：
1 执行客户端发来的命令
2 将执行后的命令最佳到 AOF缓存区
3 将执行后的写命令最佳到AOF缓存区

1可以保证将AOF定期写入和同步到AOF文件
2从子进程开始，所有命令都写AOF重写缓存区

等子进程按成AOF重写，会向父进程发送信号，然后偶将AOF重写缓存区写入缓存文件，替换原有文件。

# 33 Watch





#  34 redis 的数据结构，对长字符串和短字符串处理有什么不同

#   35 Redis 缓存穿透布隆过滤器



# 36 redis 使用的是哪种集群模式，有多少个节点，不同角色如何配置；

# 37 主观下线与客观下线是怎么回事；

# 38 redis cluster 模式是否有中间协调者，选举机制是怎么样的，如何判断一个节点已下线

# 39 redis 集群中节点数不能过多是为什么；

#   40 服务器是怎么虚拟节点的？

#  41 redis 集群扩容是如何 reblance 的

# 42 redis cluster 如何搭建，master-slave 模式，如何选主

#  43 redis cluster 模式是否有中间协调者，选举机制是怎么样的，如何判断一个节点已下线；

# 44 redis 集群中节点数不能过多是为什么

# 45 redis集群不支持的命令

# 46  热点问题与击穿的解决 

# 47 Redis  分布式锁



# 







# 48 主观下线与客观下线

# 49 大数据量 json 串放在 mongdb 有什么优势（为什么不放入 mysql 或者 redis）

# 50 redis 集群中节点数不能过多是为什么；



# 51 zset 排序原理

redis 主挂掉如何解决呢？ 分别从单纯的主从和哨兵两个方向回答了该问题

 



# 52 redis 持久化，AOF 重写过程，AOF 的配置写入磁盘的频率，一般怎么配置，

# 53 AOF+RDB 一 起使用，数据恢复过程

# 54 bitmap 可以精准去重，那么非精准去重的方法有哪些

# 55 redis 里 HashMap 适合存什么类型的数据

 # 56 redis 热 key 问题如何解决(本地缓存，热 key 备份) 



# 57 redis最多能存多少数据



Redis can handle up to 2^32 keys, and was tested in practice to handle at least 250 million keys per instance.

 

Every hash, list, set, and sorted set, can hold 2^32 elements.

 

In other words your limit is likely the available memory in your system.



配置文件 做大内存 物理内存的3分之二



# 58 redis数据结构有哪些 使用时注意什么，hash底层了解过吗







 # 59 redis 的跳表知道吗，为什么不用红黑树。

我回答了因为红黑树实现比跳表复杂

 

# 60 redis 线程模型



#  61 在一台服务器上面可以创建多个 Redis 实例 

# 62 allkeys lru怎么实现的



# 63 redis zset实现延时队列







