# 其他

# 一 、位运算

# 1 338  [比特位计数](https://leetcode-cn.com/problems/counting-bits/)



给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]

![1596123657529](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\1596123657529.png)

```java
public class Solution {
  public int[] countBits(int num) {
      int[] ans = new int[num + 1];
      for (int i = 1; i <= num; ++i)
        ans[i] = ans[i >> 1] + (i & 1); // x / 2 is x >> 1 and x % 2 is x & 1
      return ans;
  }
}
```

# 2 [面试题 16.07. 最大数值](https://leetcode-cn.com/problems/maximum-lcci/)

# 3 [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2

```java
class Solution {
    public int majorityElement(int[] nums) {
     
     int cunt = 0;
     
     Integer con = null;

     for(int num : nums){
        if(cunt ==0){
            con = num;
        }
        cunt  = cunt + (con == num? 1:-1);
     }
     return con;


    }
}
```

# 4  [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

# 4  137 [只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii) 

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99

```java
class Solution {
  public int singleNumber(int[] nums) {
    int seenOnce = 0, seenTwice = 0;

    for (int num : nums) {
      // first appearence: 
      // add num to seen_once 
      // don't add to seen_twice because of presence in seen_once

      // second appearance: 
      // remove num from seen_once 
      // add num to seen_twice

      // third appearance: 
      // don't add to seen_once because of presence in seen_twice
      // remove num from seen_twice
      seenOnce = ~seenTwice & (seenOnce ^ num);
      seenTwice = ~seenOnce & (seenTwice ^ num);
    }

    return seenOnce;
  }
}

```

# 5 [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

**示例 :**

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

**注意：**

1. 结果输出的顺序并不重要，对于上面的例子， `[5, 3]` 也是正确答案。
2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

```java
class Solution {
  public int[] singleNumber(int[] nums) {
    //但是 bitmask 会保留只出现一次的两个数字（x 和 y）之间的差异。
    int bitmask = 0;
    for (int num : nums) bitmask ^= num;
    //我们可以直接从 bitmask 中提取 x 和 y 吗？不能，但是我们可以用 bitmask 作为标记来分离 x 和 y。
    // 最右一位 不是来自x 就是y bitmask & (-bitmask) 保留 bitmask 最右边的 1，这个 1 要么来自 x，要么来自 y。
    int diff = bitmask & (-bitmask);

    int x = 0;
    // 找到x或y
    for (int num : nums) if ((num & diff) != 0) x ^= num;

    return new int[]{x, bitmask^x};
  }
}
```

# 6 191 整数有多少个位是1



# 7 [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)





# 8 [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

```java
class Solution {
    //https://leetcode-cn.com/problems/sum-of-two-integers/solution/li-yong-wei-cao-zuo-shi-xian-liang-shu-qiu-he-by-p/
    public int getSum(int a, int b) {
      while(b!=0){
        int temp = a^b;
        b= (a&b)<<1;
        a = temp;

      }
      return a;

    }
}
```

# 421 [数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)



# [重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)

# [最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

#### [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

```java
给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

示例 1:

输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。
示例 2:

输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。
示例 3:

输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。

    
    
   //用二进制的一位表示某一个字母是否出现过，0表示没出现，1表示出现。"abcd"二进制表示00000000 00000000 00000000 00001111、"bc"二进制表示00000000 00000000 00000000 00000110。当两个字符串没有相同的字母时，二进制数与的结果为0。

class Solution {
    public int maxProduct(String[] words) {
        int B[] = new int[words.length];
        for(int i =0;i<words.length;i++) {
            for(int j =0;j<words[i].length();j++) {
              B[i] |= (1<<words[i].charAt(j)-'a'); 
            }
        }
        int max =0;
        for(int i =0;i<words.length;i++) {
           for(int j =i+1;j<words.length;j++) {
               if((B[i]&B[j])==0){
                max = Math.max(words[i].length() *words[j].length(),max);
               }
           } 
        }
        return max;

    }
}
```



# 二 、KMP算法

## 28. 实现 strStr()

```java
class Solution {
    public int strStr(String haystack, String needle) {
      if(needle ==null || needle.equals("")){
          return 0;
      }
      int len1 = haystack.length();
      int len2 = needle.length();
      if(len2>len1) {
          return -1;
      }
      int i =0;
      int j =0;

      int [] nexts = getNext(needle.toCharArray());
      while(i<len1 && j<len2) {

        if(haystack.charAt(i) == needle.charAt(j)) {
           i++;
           j++;
        } else {
           if(nexts[j]==-1) {
               i++;
           } else{
               j = nexts[j];
           }
        }
        if(j==len2) return i-len2;
      } 
      return -1;
    }

    private int [] getNext(char [] chars) {
        int n = chars.length;
        if(n==0) {
          return  new int[] {-1};
        }
        int [] next = new int [n];
        next[0] =-1;
        int k =-1;
        int j =0;
        while(j<n-1) {
            if(k==-1||chars[k]==chars[j]) {
                k++;
                j++;
                next[j] = k;
            } else {
              k= next[k];
            }

        }
        return next; 
    }

}
```

## 25 [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

示例 1:

输入: "aacecaaa"
输出: "aaacecaaa"
示例 2:

输入: "abcd"
输出: "dcbabcd"

```java
class Solution {
    public String shortestPalindrome(String s) {
        if(s==null||s.length() ==0) {
            return "";
        }
        String s2 = s+"#" + new StringBuilder(s).reverse().toString();
        return new StringBuilder(s.substring(getNext(s2.toCharArray())+1)).reverse().toString()+s;
    }
    private int getNext(char [] chars) {
        int n = chars.length;
        if(n==0) {
            return -1;
        }
        int [] next = new int [n];
        next[0] =-1;
        int k =-1;
        int j =0;
        while(j<n-1) {
            if(k==-1||chars[k]==chars[j]) {
                k++;
                j++;
                next[j] = k;
            } else {
              k= next[k];
            }

        }
        return next[n-1]; 
    } 
}
```



# 三、前缀和

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)



```java
class Solution {
//https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/
public int subarraySum(int[] nums, int k) {

   return method2(nums,k);

}
// 暴力法
int method1(int[] nums, int k){
    int cunt = 0;
    for(int i=0;i<nums.length;i++){
       int sum =0;
       for(int j =i;j<nums.length;j++){
         sum = sum + nums[j];
         if(sum==k){
             cunt++;
         } 
       }
    } 

         return cunt;

}
int method2(int[] nums, int k){

    int pre = 0;
    int cunt =0;
    Map<Integer,Integer> map = new HashMap<>();
    //[3] [1,-1]
    map.put(0,1);
    for(int i =0;i<nums.length;i++){
       pre = pre + nums[i];
 
       if(map.containsKey(pre-k)){
           cunt  = cunt + map.get(pre-k);
       }
       map.put(pre,map.getOrDefault(pre,0)+1);
    }

     return cunt;
}}
```

#### [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

```java
class Solution {
    int[] dp = new int[10010];
    public boolean checkSubarraySum(int[] nums, int k) {
        if(nums.length < 2) return false;
        //k==0时单独考虑，其实和k!=0时只有做不做模运算的区别
        if(k == 0){
            for(int i = 0; i < nums.length; i++){
                for(int j = 0; j < nums.length-i; j++){
                    dp[j] = (dp[j]+nums[j+i]);
                    if(i != 0 && dp[j] == 0) return true;
                }
            }
        return false;
        }
        //当i=k时，dp[j]表示以j为起始下标，nums中连续k+1个整数的和
        //如当i=0时，相当于将nums拷贝到dp
        //i=1时，dp[0]相当于以0为起始下标，nums中2个整数的和，即nums[0]+nums[1]
        //每次计算时都可以用原来的dp进行更新，而不用一个个去加
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < nums.length-i; j++){
                dp[j] = (dp[j]+nums[j+i]) % k;
                if(i != 0 && dp[j] == 0) return true;
            }
        }
        return false;
    }
}


class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {

      int pre = 0;
      int len = nums.length;
      if(len<2) return false;
      Map<Integer,Integer> map = new HashMap<>();

      map.put(0,-1);
      for(int i=0 ;i<nums.length;i++) {
        pre +=nums[i];
        if(k!=0){
           pre = pre %k; 
        }
        if(map.containsKey(pre)) {
           if(i-map.get(pre)>1){
               return true;
           }

        } else {
              map.put(pre,i);
        }
      } 
      return false;

    }
}



```

## 327. 区间和的个数

给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。
区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

说明:
最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。

示例:

输入: nums = [-2,5,-1], lower = -2, upper = 2,
输出: 3 
解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。




## 1248 题： 统计「优美子数组
## 454 题：四数相加 II



# 四  设计类

# 146LRU设计

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

示例:

LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4

```java
class LRUCache {

    private int size;
    private int capacity;
    private Map<Integer,DlinkedNode> cache;
    private DlinkedNode head;
    private DlinkedNode tail;



    public LRUCache(int capacity) {
        this.capacity =capacity;
        this.cache = new HashMap<>();
        size =0;
        head = new DlinkedNode();
        tail = new DlinkedNode();
        head.next = tail;
        tail.pre =head;
    }
    
    public int get(int key) {
        DlinkedNode node = cache.get(key);
        if(node==null){
            return -1;
        }
        moveToHead(node);        
        return node.value;
    }
    private void moveToHead(DlinkedNode node){
         
         remove(node);
         addToHead(node);
    }

   //移动到头
    private void moveToHead(DlinkedNode node){
         
         remove(node);
         addToHead(node);
    }
   //删除节点
    private void remove(DlinkedNode node){
        //只关心 node的前后指针给了谁
        //node  。 ~*。  * = node 。*
        node.pre.next = node.next;
        node.next.pre = node.pre;

    }
    private void addToHead(DlinkedNode node){

      //先node前后指针构成，这时前后指针为空优先考虑
        node.pre = head;
        node.next = head.next;
      //在node的指针给谁
        head.next.pre = node;
      //后指针一定能够最后改  
        head.next = node;
    }

 // 移除尾节点
    private void removeTail(){
        DlinkedNode re = tail.pre;
        remove(re);
    }

    public void put(int key, int value) {

      DlinkedNode node = cache.get(key);

      if(node ==null){
         DlinkedNode newNode = new DlinkedNode(key,value); 
         size++;
         cache.put(key,newNode);
         addToHead(newNode);

         if(size>capacity){
             size--;
             cache.remove(tail.pre.key);
             removeTail();
         }

      } else{
          node.value = value;
         cache.put(key,node);
         moveToHead(node);
      }
    }

    public class DlinkedNode{
    private int value;
    private int key;
    private DlinkedNode pre;
    private DlinkedNode next;
    public DlinkedNode(int key,int value){
        this.key = key;
        this.value = value;
    }
    DlinkedNode(){}
    }




}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```



# 155min最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。


示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

```java
class MinStack {

    /** initialize your data structure here. */

    Deque<Integer> stack ;
    Deque<Integer> minStack;

    public MinStack() {
     stack = new LinkedList<>();
     minStack = new LinkedList<>();
    }
    
    public void push(int x) {
         if(minStack.isEmpty()){
             minStack.push(x);
         } else if (x<= getMin()){
             minStack.push(x);
         }                                                              


         stack.push(x);
    }
    
    public void pop() {

      if(stack.isEmpty()){
          return;
      }

      if(getMin() ==stack.pop()){
          minStack.pop();
      } 
    }
    
    public int top() {
     return stack.peek();
    }
    
    public int getMin() {

      return minStack.peek();
    }
}
```

# 232 [剑指 Offer 09. 用两个栈实现队列 ](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)  

要点：1.pushStack倒入popStack 必须一次全部倒入

​          2 popStack必须为空哪个才能倒入

​          3.dao()必须在pop和peek出现(连续pop会出空指针)，push无所谓

```java
class MyQueue {
    
    private Deque<Integer> pushStack = new LinkedList<>();
    private Deque<Integer> popStack = new LinkedList<>();

    /** Initialize your data structure here. */
    public MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        pushStack.push(x);
        
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
      dao();
     return popStack.pop();    
 
    }
    
    /** Get the front element. */
    public int peek() {
     dao();
     return popStack.peek();

    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return pushStack.isEmpty() && popStack.isEmpty();
    }

    private void dao(){
        if(!popStack.isEmpty()){
            return;
        }else{
            while(!pushStack.isEmpty()){
                popStack.push(pushStack.pop());
            }
        }
    }


}
```





# 225  [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues)（左程云-视频教程）



需要两个队列 dataQueue 和helpQueue

// 要点：1，dataQueue只留一个元素在dataQueue。其余全部导入helpQueue

​              2.操作（pop和peek）完必须交换dataQueue和helpQueue，

```java
class MyStack {

    private Queue<Integer> data = new LinkedList<>();
    private Queue<Integer> help = new LinkedList<>();
    /** Initialize your data structure here. */
    public MyStack() {

    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        data.offer(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
               while(data.size()>1){
            help.offer(data.poll());
         }
         int res = data.poll();
         swap();
         return res;
    }
    
    /** Get the top element. */
    public int top() {
        while(data.size()>1){
            help.offer(data.poll());
         }
         int res = data.poll();
         help.offer(res);
         swap();
         return res; 

    }
    /** Returns whether the stack is empty. */
    public boolean empty() {  
      return data.isEmpty();
    }

    private void swap(){
      Queue<Integer> temp = data;
      data = help;
      help = temp;
    }
}
```

# [460. LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)



#  [641. 循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)（必考 ）

1.用1个数组实现

//1.初始值front =0；tail=0；

// addfisrt front 先--在赋值，addLast tail先赋值在++

//removefisrt  front++,removeLast tail--

```java
class MyCircularDeque {

    private int [] values;
    private int size =0;
    private int front =0;
    private int tail = 0;
    private int capacity = 0;
    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        size =0;
        capacity = k;
        values = new int [k];
        tail = 0; 
    }
    
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if(isFull()){
            return false;
        }
        size++;
        front--;
        
        if(front<0){
            front =capacity-1;
        }
        values[front] = value; 
        return true;
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {

        if(isFull()){
            return false;
        }
        size++;
        values[tail] = value;
        tail++;
        
        if(tail>capacity-1){
            tail =0;
        }
        
        return true;   
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if(isEmpty()) {
           return false;
        } 
        size--;
        front++;
        if(front>capacity-1) {
           front =0;
        } 
        return true;


    }
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
         if(isEmpty()) {
             return false;
         }
         size--;
         tail--;
         if(tail<0) {
             tail = capacity -1;
         }
         return true;
    }
    
    /** Get the front item from the deque. */
    public int getFront() {
        if(isEmpty()){
            return -1;
        }  
        return values[front];
    }
    
    /** Get the last item from the deque. */
    public int getRear() {
        if(isEmpty()){
            return -1;
        }  

        if(tail-1<0){
            return values[capacity-1];
        }
        return values[tail-1];  

    }
    
    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
         return size==0;
    }
    
    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
         return size == capacity;
    }
}
```

2 用两个队列实现







#  用数组实现 队列（初级3 必考）



| --队列      | --双端队列  |
| ----------- | ----------- |
| add offer   | addLast     |
| remove poll | removeFirst |
| peek        | peekFirst   |

# ArrayDeque用数组实现的自动扩容的非循环双端队列

# ArrayBlockingQueue用数组实现固定容量的循环阻塞队列





# 五 并差集

初级班 第七节

1.查询两个元素是否属于一个集合

2.合并两个集合

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

## 305   [岛屿数量 II](https://leetcode-cn.com/problems/number-of-islands-ii) 

# 306 [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)




