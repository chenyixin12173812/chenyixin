# 1 幂等设计：

1 redis 存用户token



2 数据库唯一键

业务主键和时间戳低位组成唯一键，时间过了一会，就不冲突了

# 2 接口防重？

在一定的时间内请求同一接口，同一参数。由于请求是健康请求，会执行正常的业务逻辑，从而产生大量的废数据。

## 2.1 实现

第一种：前台在请求接口的时候，传递一个唯一值，然后在对应接口判断该唯一值，在一定的时间内是否被消费过

第二种：采用Spring AOP理念，实现请求的切割，在请求执行到某个方法或某层时候，开始拦截进行，获取该请求的参数，用户信息，请求地址，存入**redis中并放置过期时间，进行防重**（推荐使用）

# 2 .2两种处理方法的利弊

第一种：局限性太高，前台必须传递一个唯一值，就算请求到达指定后台服务，写一个拦截器，需要配置太多不需要拦截的方法，也许你会说，可以拦截有规则的请求地址，这样真的好吗?

第二种：作为一名JAVA后台开发，Spring应该是熟悉的不能再熟悉了，Spring核心AOP又用了多少，针对以上请求，只需要写一个注解类，然后切面到该注解上，在需要防重的方法上只需添加注解即可





