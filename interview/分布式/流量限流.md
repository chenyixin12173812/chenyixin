# 流量限流

一般需要多级限流控制





# 0 常用算法

## 3.1计数器算法（固定窗口）

计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略，下一个周期开始时，进行清零，重新计数，实现简单。计数器算法方式限流对于周期比较长的限流，存在很大的弊端，有严重的临界问题。

**致命缺点：**没有处理好边界，边界最后一秒和下一个窗口第一秒，承受2倍QPS.

## 3.2滑动窗口算法：

**致命缺点：**一样2倍QPS.问题，1个后半段和2的前半段。

将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。此算法可以很好的解决固定窗口算法的临界问题

所谓的滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。

滑动时间窗口如下图所示：

![img](https://pic1.zhimg.com/80/v2-e507852faabae373c8635a9a5c796eec_720w.jpg)



其中每一小个表示 10s，被红色虚线包围的时间段则为需要判断的时间间隔，比如 60s 秒允许 100 次请求，那么红色虚线部分则为 60s。

我们可以借助 Redis 的有序集合 ZSet 来实现时间窗口算法限流，实现的过程是先使用 ZSet 的 key 存储限流的 ID，score 用来存储请求的时间，每次有请求访问来了之后，先清空之前时间窗口的访问量，统计现在时间窗口的个数和最大允许访问量对比，如果大于等于最大访问量则返回 false 执行限流操作，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录，具体实现代码如下。

我们借助 Jedis 包来操作 Redis，实现在 pom.xml 添加 Jedis 框架的引用，配置如下：

```text
<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.3.0</version>
</dependency>
```

具体的 Java 实现代码如下：

```text
import redis.clients.jedis.Jedis;

public class RedisLimit {
    // Redis 操作客户端
    static Jedis jedis = new Jedis("127.0.0.1", 6379);

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 15; i++) {
            boolean res = isPeriodLimiting("java", 3, 10);
            if (res) {
                System.out.println("正常执行请求：" + i);
            } else {
                System.out.println("被限流：" + i);
            }
        }
        // 休眠 4s
        Thread.sleep(4000);
        // 超过最大执行时间之后，再从发起请求
        boolean res = isPeriodLimiting("java", 3, 10);
        if (res) {
            System.out.println("休眠后，正常执行请求");
        } else {
            System.out.println("休眠后，被限流");
        }
    }

    /**
     * 限流方法（滑动时间算法）
     * @param key      限流标识
     * @param period   限流时间范围（单位：秒）
     * @param maxCount 最大运行访问次数
     * @return
     */
    private static boolean isPeriodLimiting(String key, int period, int maxCount) {
        long nowTs = System.currentTimeMillis(); // 当前时间戳
        // 删除非时间段内的请求数据（清除老访问数据，比如 period=60 时，标识清除 60s 以前的请求记录）
        jedis.zremrangeByScore(key, 0, nowTs - period * 1000);
        long currCount = jedis.zcard(key); // 当前请求次数
        if (currCount >= maxCount) {
            // 超过最大请求次数，执行限流
            return false;
        }
        // 未达到最大请求数，正常执行业务
        jedis.zadd(key, nowTs, "" + nowTs); // 请求记录 +1
        return true;
    }
}
```



## 3.2 漏桶法

**优点：可以强行限制数据的传输速率**

滑动时间算法有一个问题就是在一定范围内，比如 60s 内只能有 10 个请求，当第一秒时就到达了 10 个请求，那么剩下的 59s 只能把所有的请求都给拒绝掉，而漏桶算法可以解决这个问题。

漏桶算法类似于生活中的漏斗，无论上面的水流倒入漏斗有多大，也就是无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;当上面的水流速度小于下面流出的速度的话，漏斗永远不会被装满，并且可以一直流出。

漏桶算法的实现步骤是，先声明一个队列用来保存请求，这个队列相当于漏斗，当队列容量满了之后就放弃新来的请求，然后重新声明一个线程定期从任务队列中获取一个或多个任务进行执行，这样就实现了漏桶算法。

上面我们演示 Nginx 的控制速率其实使用的就是漏桶算法，当然我们也可以借助 Redis 很方便的实现漏桶算法。

我们可以使用 Redis 4.0 版本中提供的 Redis-Cell 模块，该模块使用的是漏斗算法，并且提供了原子的限流指令，而且依靠 Redis 这个天生的分布式程序就可以实现比较完美的限流了。

## 3.3令牌桶法

**优点：除了可以控制流量还允许一定量的突发。**

  对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图2所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。  漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞 

在令牌桶算法中有**一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行**，如下图所示：

假如用户配置的**平均发送速率为r**，则每隔1/r秒一个令牌被加入到桶中；

假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；

当一个n个字节的[数据包](https://baike.baidu.com/item/数据包)到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络；

如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外；

算法允许最长b个字节的突发，但从长期运行结果看，**数据包的速率被限制成常量r**。对于在流量限制外的数据包可以以不同的方式处理：







![img](https://pic4.zhimg.com/80/v2-3b57dc5c62fc560afcbf37021a8d8aeb_720w.jpg)

>  并不能说明令牌桶一定比漏洞好，她们使用场景不一样。令牌桶可以用来保护自己，主要用来对调用者频率进行限流，为的是让自己不被打垮。所以如果自己本身有处理能力的时候，如果流量突发（实际消费能力强于配置的流量限制），那么实际处理速率可以超过配置的限制。而漏桶算法，这是用来保护他人，也就是保护他所调用的系统。主要场景是，当调用的第三方系统本身没有保护机制，或者有流量限制的时候，我们的调用速度不能超过他的限制，由于我们不能更改第三方系统，所以只有在主调方控制。这个时候，即使流量突发，也必须舍弃。因为消费能力是第三方决定的。
> 总结起来：如果要让自己的系统不被打垮，用令牌桶。如果保证被别人的系统不被打垮，用漏桶算法 # 



# 1 4层限流（tcp/ip）

并发连接数，新建连接限流。。

# 2 7层限流(http)

接口来源限流，接口降级，黑白名单，优先流控，配额等。一般基于漏桶法实现。

# 3 服务端限流

接口参数限流，接口降级，黑白名单、服务降级、熔断，动态流控、全局流控。令牌桶法法实现



> 

# 4 对比

| --             | sentinel                                         | Hystrix                                               | resillence4j                                               | h内部                                             |      |      |
| -------------- | ------------------------------------------------ | ----------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------- | ---- | ---- |
| 隔离支持       | 信号量隔离                                       | 线程池/信号量隔离                                     | 信号量隔离                                                 | 不支持                                            |      |      |
| 实时统计       | 滑动窗口（leapArray）                            | 滑动窗口（基于RxJava）                                | Ring Bit buffer                                            | 滑动窗口（leapArray）                             |      |      |
| 动态规则配置   | 支持多种数据源                                   | 支持多种数据源                                        | 有限支持                                                   |                                                   |      |      |
| 熔断策略       | 相应时间<br />异常比<br />异常数<br />不支持半开 | 异常比<br />支持半开<br />1次执行判定是否进行状态转换 | 异常比<br />相应时间<br />可配置一定的次数执行是否状态转换 | 支持sentinel和可配置一定的次数执行是否状态转换    |      |      |
| 扩展性         | 多个扩展点                                       | 插件形式                                              | 接口形式                                                   | 插件形式                                          |      |      |
| 注解支持       | 支持                                             | 支持                                                  | 支持                                                       | 支持                                              |      |      |
| 资源限流       | 基于QPS<br />基于调用关系                        | 有限支持                                              | 令牌桶算法                                                 | 基于QPS<br />资源下的参数级配置<br />支持集群流控 |      |      |
| 流量整形       | 支持预热模式<br />匀速器模式<br />预热排队模式   | 不支持                                                | 简单的令牌桶算法                                           | 不支持                                            |      |      |
| 系统自适应保护 | 支持                                             | 不支持                                                | 不支持                                                     | 不支持                                            |      |      |
| LB流控和降级   | 不支持                                           | 不支持                                                | 不支持                                                     | 基于nginx+lua流量控制和降级                       |      |      |
| 控制台         | 简单版                                           | 无                                                    | 无，但可对接其他监控系统                                   | 开箱即用的控制台，动态修改配置                    |      |      |

