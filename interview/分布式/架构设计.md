# 架构设计

- 容量规划
- 架构设计
- 数据库设计
- 缓存设计
- 框架选型
- 发布方案
- 数据迁移、同步方案
- 分库分表方案
- 回滚方案
- 高并发解决方案
- 一致性选型
- 性能压测方案
- 监控报警方案

# 1 接口的幂等设计

 接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条,这就没有保证接口的幂等性

 

什么情况下需要保证接口的幂等性

  在增删改查4个操作中，尤为注意就是**增加**或者**修改**

  常见的两种实现方案: 1. 通过代码逻辑判断实现  2. 使用token机制实现   下面以支付系统为例,分别对接口的幂等性进行说明与实现

  A: 通过代码逻辑判断实现接口幂等性,只能针对一些满足判断的逻辑实现,具有一定局限性

  用户购买商品的订单系统与支付系统；订单系统负责记录用户的购买记录已经订单的流转状态（orderStatus),支付系统用于付款，提供如下接口，订单系统与支付系统通过分布式网络交互。

```
boolean pay(int accountid,BigDecimal amount) //用于付款，扣除用户的   
```

![img](https://images2018.cnblogs.com/blog/1197977/201809/1197977-20180903104203646-259570951.png)

这种情况下，支付系统已经扣款，但是订单系统因为网络原因，没有获取到确切的结果，因此订单系统需要重试。由上图可见，支付系统并没有做到接口的幂等性，订单系统第一次调用和第二次调用，用户分别被扣了两次钱，不符合幂等性原则（同一个订单，无论是调用了多少次，用户都只会扣款一次）。如果需要支持幂等性，付款接口需要修改为以下接口：

 boolean pay(int orderId,int accountId,BigDecimal amount)

通过orderId来标定订单的唯一性，付款系统只要检测到订单已经支付过，则第二次调用不会扣款而会直接返回结果：

![img](https://images2018.cnblogs.com/blog/1197977/201809/1197977-20180903104548042-115539224.png)

在不同的业务中不同接口需要有不同的幂等性，特别是在分布式系统中，因为网络原因而未能得到确定的结果，往往需要支持接口幂等性。

随着分布式系统及微服务的普及，因为网络原因而导致调用系统未能获取到确切的结果从而导致重试，这就需要被调用系统具有幂等性。例如上文所阐述的支付系统，针对同一个订单保证支付的幂等性，一旦订单的支付状态确定之后，以后的操作都会返回相同的结果，对用户的扣款也只会有一次。这种接口的幂等性，简化到数据层面的操作：

```
update userAmount set amount = amount - 'value' ,paystatus = 'paid' where orderId= 'orderid' and paystatus = 'unpay'其中value是用户要减少的订单，paystatus代表支付状态，paid代表已经支付，unpay代表未支付，orderid是订单号。在上文中提到的订单系统，订单具有自己的状态（orderStatus),订单状态存在一定的流转。订单首先有提交（0），付款中（1），付款成功（2），付款失败（3），简化之后其流转路径如图：当orderStatus = 1 时，其前置状态只能是0，也就是说将orderStatus由0->1 是需要幂等性的
update Order set orderStatus = 1 where OrderId = 'orderid' and orderStatus = 0
```

  当orderStatus 处于0，1两种状态时，对订单执行0->1 的状态流转操作应该是具有幂等性的。这时候需要在执行update操作之前检测orderStatus是否已经=1，如果已经=1则直接返回true即可。

  但是如果此时orderStatus = 2,再进行订单状态0->1 时操作就无法成功，但是幂等性是针对同一个请求的，也就是针对同一个requestid保持幂等。

  这时候再执行

```
 update Order set orderStatus = 1 where OrderId = 'orderid' and orderStatus = 0
```

  接口会返回失败，系统没有产生修改，如果再发一次，requestid是相同的，对系统同样没有产生修改。

```
 
```

 B: 使用token机制实现接口幂等性,通用性强的实现方法

   token机制实现步骤:

   生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token

​    提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,页面再次提交携带的token是已删除的token后台验证会失败不让提交


   token特点：  要申请，一次有效性，可以限流

   注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用

# 1应用架构发展历史

要了解微服务架构提出的背景，首先我们来看一下应用架构的发展历程，如下图所示：

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/uH1hdj5dlcPRqFpDnlsmatDOLZQjxOiaErCW1Et1IuPXxaasabpibe9E0zTQJDricJuAicZCv620jVhjQlPdNt6QZA/640?wx_fmt=png)

- 单体应用：传统应用的开发技术为.NET、J2EE等技术，开发完成后部署在websphere、weblogic这样的商业容器中（或者开源的tomcat）。应用间的交互一般通过CORBA、DCOM这样RPC风格的组件进行，此时并没有服务化的概念。部署的环境一般为小型机、服务器。
- SOA架构：业界在意识到了系统集成标准化的重要性后，提出了SOA的理念。SOA强调的是服务化、标准化，通过制定统一的应用接口标准，所有的应用都可以方便的提供服务，并且也可以快速调用其他应用提供的服务，通过一个集中化的服务中间件，系统集成的效率大大提高。经典的落地场景就是ESB企业服务总线。交互协议多用基于SOAP的web service。在这个时期，出现了虚拟化技术，应用可以部署在vmware虚拟机中，大大提高了资源的利用效率。
- 微服务：其实在martin fowler写那篇经典的微服务论述文章前，业界很多公司早就在实践微服务了。国外的有netflix oss技术栈，国内的有大名鼎鼎的dubbo框架。esb在落地过程中碰到了很多问题，集中化的中心节点很容易造成性能瓶颈，并可能产生单点故障，在互联网公司的实践中上千甚至上万的服务，已经不可能通过esb去承载。微服务与传统的esb区别就是去中心化，去掉了中心esb节点，取而代之的是一个分布式的服务化框架，提供服务注册、服务发现、限流熔断、配置管理等一系列高级功能。由于互联网的流行，此时的交互协议多为轻量级的RESTful风格协议。这个时期，是云计算真正落地的时期，以aws为代表的Iaas技术大行其道，从根本上改变了应用部署的方式。（事实上，netflix就是基于亚马逊的EC2弹性节点来动态的增加、减少微服务实例的，应用架构的灵活性大大增加）
- 云原生：云原生其实就是微服务的一种落地，但我认为，云原生已经可以看作是下一代的应用架构了。它从平台层面重新审视整个微服务实施中的关注点，并且以宏观视角给出了完整的解决方案，强调与devops的整合，整体抽象层次最高，且做到了语言无关，这是上一代微服务所做不到的。需要注意的是，在云原生时代，**应用和基础架构需要进行深度集成，换句话说，只有你在kubernetes这样的云基础设施上部署的应用，才可以算成是“云原生”应用。应用充分利用了基础架构的能力（微服务能力**），这才是“云原生”的真谛（天生被设计需要跑在云上的应用）。



11、分布式session一致性；

12、分布式接口的幂等性设计「不能重复扣款」；

