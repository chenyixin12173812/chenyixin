# 1 降级





# 4 对比

| --                                | sentinel                                         | Hystrix                                               | resillence4j                                               | h内部                                             |      |      |
| --------------------------------- | ------------------------------------------------ | ----------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------- | ---- | ---- |
| 隔离支持                          | 信号量隔离                                       | 线程池/信号量隔离                                     | 信号量隔离                                                 | 不支持                                            |      |      |
| 实时统计                          | 滑动窗口（leapArray）                            | 滑动窗口（基于RxJava）                                | Ring Bit buffer                                            | 滑动窗口（leapArray）                             |      |      |
| 动态规则配置                      | 支持多种数据源                                   | 支持多种数据源                                        | 有限支持                                                   |                                                   |      |      |
| 熔断策略                          | 相应时间<br />异常比<br />异常数<br />不支持半开 | 异常比<br />支持半开<br />1次执行判定是否进行状态转换 | 异常比<br />相应时间<br />可配置一定的次数执行是否状态转换 | 支持sentinel和可配置一定的次数执行是否状态转换    |      |      |
| 扩展性                            | 多个扩展点                                       | 插件形式                                              | 接口形式                                                   | 插件形式                                          |      |      |
| 注解支持                          | 支持                                             | 支持                                                  | 支持                                                       | 支持                                              |      |      |
| 资源限流                          | 基于QPS<br />基于调用关系<br />支持集群流控      | 有限支持                                              | 令牌桶算法                                                 | 基于QPS<br />资源下的参数级配置<br />支持集群流控 |      |      |
| 流量整形                          | 支持预热模式<br />匀速器模式<br />预热排队模式   | 不支持                                                | 简单的令牌桶算法                                           | 不支持                                            |      |      |
| 系统自适应保护（cpu、内存使用率） | 支持                                             | 不支持                                                | 不支持                                                     | 不支持                                            |      |      |
| LB（负载均衡）流控和降级          | 不支持                                           | 不支持                                                | 不支持                                                     | 基于nginx+lua流量控制和降级                       |      |      |
| 控制台                            | 简单版                                           | 无                                                    | 无，但可对接其他监控系统                                   | 开箱即用的控制台，动态修改配置                    |      |      |

# 5 Hystrix与Sentinel 



## 5.1 Hystrix 

关注点在于以隔离和熔断为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。

线程池 timeout 和异常。

semaphore 技术可以用来限流和削峰，但是不能用来对调用延迟的服务进行 timeout 和隔离

支持线程池与信号量。

### 线程池机制的优点

- 任何一个依赖服务都可以被隔离在自己的线程池内，即使自己的线程池资源填满了，也不会影响任何其他的服务调用。
- 服务可以随时引入一个新的依赖服务，因为即使这个新的依赖服务有问题，也不会影响其他任何服务的调用。
- 当一个故障的依赖服务重新变好的时候，可以通过清理掉线程池，瞬间恢复该服务的调用，而如果是 tomcat 线程池被占满，再恢复就很麻烦。
- 如果一个 client 调用库配置有问题，线程池的健康状况随时会报告，比如成功/失败/拒绝/超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机。
- 基于线程池的异步本质，可以在同步的调用之上，构建一层异步调用层。

简单来说，最大的好处，就是资源隔离，确保说任何一个依赖服务故障，不会拖垮当前的这个服务。

### 线程池机制的缺点

- **线程池机制最大的缺点就是增加了 CPU 的开销**。
  除了 tomcat 本身的调用线程之外，还有 Hystrix 自己管理的线程池。
- 每个 command 的执行都依托一个独立的线程，会进行排队，调度，还有上下文切换。
- Hystrix 官方自己做了一个多线程异步带来的额外开销统计，通过对比多线程异步调用+同步调用得出，Netflix API 每天通过 Hystrix 执行 10 亿次调用，每个服务实例有 40 个以上的线程池，每个线程池有 10 个左右的线程。）最后发现说，用 Hystrix 的额外开销，**就是给请求带来了 3ms 左右的延时，最多延时在 10ms 以内**，相比于可用性和稳定性的提升，这是可以接受的。

# 5.2 Sentinel 

侧重点在于：只支持信号量

- 多样化的流量控制
- 熔断降级
- 系统负载保护
- 实时监控和控制台
- 集群
- 组策略
- qps
- 调用关系



# 一  Sentinel 

### strategy

基于调用关系的流量控制，也有三种情况可以选择：

- STRATEGY_DIRECT

根据调用方进行限流。ContextUtil.enter(resourceName, origin) 方法中的 origin 参数标明了调用方的身份。

如果 strategy 选择了DIRECT ，则还需要根据限流规则中的 limitApp 字段根据调用方在不同的场景中进行流量控制，包括有：”所有调用方“、”特定调用方origin“、”除特定调用方origin之外的调用方“。

- STRATEGY_RELATE

根据关联流量限流。当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联，可使用关联限流来避免具有关联关系的资源之间过度的争抢。

比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。

举例来说：read_db 和 write_db 这两个资源分别代表数据库读写，我们可以给 read_db 设置限流规则来达到写优先的目的：设置 FlowRule.strategy 为 RuleConstant.STRATEGY_RELATE，同时设置 FlowRule.refResource 为 write_db。这样当写库操作过于频繁时，读数据的请求会被限流。

- STRATEGY_CHAIN

根据调用链路入口限流。假设来自入口 Entrance1 和 Entrance2 的请求都调用到了资源 NodeA，Sentinel 允许根据某个入口的统计信息对资源进行限流。

举例来说：我们可以设置 FlowRule.strategy 为 RuleConstant.CHAIN，同时设置 FlowRule.refResource 为 Entrance1 来表示只有从入口 Entrance1 的调用才会记录到 NodeA 的限流统计当中，而对来自 Entrance2 的调用可以放行。

### controlBehavior

流控策略，主要是发生拦截后具体的流量整形和控制策略，目前有三种策略，分别是：

- CONTROL_BEHAVIOR_DEFAULT

这种方式是：**直接拒绝**，该方式是默认的流量控制方式，当 qps 超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。

这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位。

- CONTROL_BEHAVIOR_WARM_UP

这种方式是：**排队等待** ，又称为 **冷启动**。该方式主要用于当系统长期处于低水位的情况下，流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。

通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。

- CONTROL_BEHAVIOR_RATE_LIMITER

这种方式是：**慢启动**，又称为 **匀速器模式**。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。

这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。

具体的 FlowRule 可以用下面这张图表示：









规则定义好了之后，启动应用后，就会自动对我们的业务代码进行保护了，当然实际生产环境中不可能通过硬编码的方式来定义规则的，sentinel 为我们提供了 DataSource 接口，通过实现该接口可以自定义规则的存储数据源。







