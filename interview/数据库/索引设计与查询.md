# 索引设计与查询

 # 面试问题 

SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？
如何写sql能够有效的使用到复合索引？
一条sql执行过长的时间，你如何优化，从哪些方面入手？
什么是最左前缀原则？什么是最左匹配原则？ 

# 一.基本规范

1，不要使用外键

表达超过100w行，修改需要加锁，影响性能。

2 左前缀原则

3 is null和 is not null不能使用索引

4 like （%abc%）会导致索引失效

如果不得不使用like进行模糊查询时，不要在关键字前面加%。
反例：

```abap
select id,name,age from persons where name like '%abc%'
```



如果在关键字前面加%，那么查询是肯定要走全表查询的。
正例：

```abap
select id,name,age from persons where name like 'abc%'
```

 若要提高效率，可以考虑全文检索。 

5 or 是困难谓词（可以使用in（mysql优化了in可以使用索引））  否则将导致引擎放弃使用索引而进行全表扫描 

6 查询字符串 不加引号会使索引失效

**索引失效会导致行锁变表锁**。比如 vchar 查询不写单引号的情况

7.在索引上计算（计算，函数，手动转换）会导致索引失效。

8  避免在整个表上使用count(*) ，它可能会将整个表锁住 

9  保持查询一致，这样后续类似的查询就能使用查询缓存了 

10  如果合适，用 GROUP BY 代替 DISTINCT 

11  在 WHERE、GROUP BY 和 ORDER BY 的列上加上索引 

12 避免select * ，最小化你要查询的数据，只获取你需要的数据 

13  保证索引简单，不要在同一列上加多个索引 

14  MySQL 会选择错误的索引，这种情况使用 USE INDEX 

15   当服务器的负载增加时，使用SHOW PROCESSLIST来查看慢的/有问题的查询 

16  索引字段少于5个时，UNION 操作用 LIMIT，而不是 OR 

17  应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描 

18  in 和 not in 也是困难谓词，否则会导致全表扫描 

19 关联代替子查询

例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示： 

DELETE FROM customerinfo 
WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo ) 

　　使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）.. 替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成： 

SELECT * FROM customerinfo 
WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo ) 

　　如果使用连接（JOIN）.. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下： 

SELECT * FROM customerinfo 
LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo. 
CustomerID 
WHERE salesinfo.CustomerID IS NULL 

　　连接（JOIN）.. 之所以更有效率一些，是因为 MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作 ，两个表都可以使用索引。

20  尽量避免大事务操作，提高系统并发能力 

21 使用索引字段和 ORDER BY 来代替 MAX 

22  使用 INSERT ON DUPLICATE KEY 或 INSERT IGNORE 来代替 UPDATE，避免 UPDATE 前需要先 SELECT

23 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样以避免系统表的较长时间锁定 

24、避免使用 ORDER BY RAND()。 

![\](http://www.2cto.com/uploadfile/Collfiles/20161021/201610211012372353.png)

上面的查询，会导致每条记录都执行rand()，成本很高！

建议，通过mt_rand()，先确定的随机主键，再从数据表中获取数据。25、LIMIT M,N 在特定场景下会降低查询效率，有节制使用。 
26、使用 UNION 来代替 WHERE 子句中的子查询。 
27、对 UPDATE 来说，使用 SHARE MODE 来防止排他锁。 
28、重启 MySQL 时，记得预热数据库，确保将数据加载到内存，提高查询效率。 
29、使用 DROP TABLE ，然后再 CREATE TABLE ，而不是 DELETE FROM ，以删除表中所有数据 

30 尽量用union all代替union
union和union all的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union 

31 避免类型转换和隐式转换

这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换：

人为在column_name 上通过转换函数进行转换直接导致 MySQL(实际上其他数据库也会有同样的问题)无法使用索引，如果非要转换，应该在传入的参数上进行转换，由数据库自己进行转换，

如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转换处理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行处理而交由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造成执行计划问题

42 大量数据的插入

多条 insert或者Load data into table（从文件里载入数据到表里）

建议，先关闭约束及索引，完成数据插入，再重新生成索引及约束

43 对于并发性的SQL

少用（不用）多表操作（子查询，联合查询），而是将复杂的SQL拆分多次执行。如果查询很原子（很小），会增加查询缓存的利用率

44 单库和索引不查过500G

45 单库表不超过150个

46 单表字段不超过80个

47 禁止使用 存储过程、触发器、Event实现逻辑

48 禁止使用视图

视图无法完成sql审核和优化，容易产生性能问题。

49 禁止外键

50 表的索引不超过5个

51 表join 应有索引

52 尽量满足2NF，冗余可以不满足3NF

53 SQL中的in不超过500个

54多使用等值，《，》使后面的字段无法使用索引

55 update 、delete 不使用limit

56 update 、delete 不使用order by 。group by

57 多表关联必须使用表的别名





# 二 字段数据类型

1.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

2 .尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来

3 时间字段使用datetime 不适用timesstamp

4禁止使用Bob或text

5 varchar 长度小于4000

6禁止字符类型放入时间

7禁止字符类型放入数字

8禁止表字段 单独定义字符集

9 禁止使用哪个ENUM 使用TINYINNT代替



MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。

- 更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。
  简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。
- 尽量避免NULL：通常情况下最好指定列为NOT NULL



# 三 索引设计

## 1 三星索引

2

1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2）较频繁作为查询条件的字段才去创建索引

3）更新频繁字段不适合创建索引

4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)

5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

6）定义有外键的数据列一定要建立索引。

7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8）对于定义为text、image和bit的数据类型的列不要建立索引。





# 3 索引设计

1. 单表索引数目不能超过5个

  注：聚簇索引造成的存储和查询成本当索引过多时，性能降低很快

2. 根据业务需求设计索引，如果没有查询需求，干嘛要去建索引呢

3. 一个字段的值范围很小，不要设置索引，索引不生效同事浪费插入性能

  注：当索引的值就三五个，范围很小时，数据库进行的基本是全表扫描，没必要建索引

4. 如果有幂等性需求，对需要幂等字段或字段组合，设置数据库唯一索引

5. null值对索引是一大伤害，所以不要让索引的列有null值存在

6. 尽量加索引的字段的数据类型小，也就是能用整数不用varchar能用短的varchar不用长的varchar，不要在text上设置索引

7. 一个索引包含的字段数不能超过3个

  8. 尽量在静态数据上建立索引，频繁变动数据建索引，每次db都要考虑是否重建B+树

  注：

  （1）如账户，userId设置为唯一索引，一个人只能有一个铜板账户，静态数据

  （2）收支流水表的userID设置普通索，查询效率高，查询需求

  （3）create_time 默认加索引

（4）a,b,c  组合索引，索引构建是用a+b+c进行构建的索引，如果是btree索引，查询的时候 abc|ab|a三种查询条件都会走索引，不需要对a和ab重复创建索引 ，但是 like '%b'|'%bc'|'%c'不会走索引，所以，组合索引，一定使用频率高的放在最左边  



### 

1. 全值匹配我最爱
2. 最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)
3. 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列
5. 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select
6. is null ,is not null 也无法使用索引
7. like "xxxx%" 是可以用到索引的，like "%xxxx" 则不行(like "%xxx%" 同理)。like以通配符开头('%abc...')索引失效会变成全表扫描的操作，
8. 字符串不加单引号索引失效
9. 少用or，用它来连接时会索引失效
10. <，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描

**一般性建议**

- 对于单键索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
- 少用Hint强制索引

# 4 查询优化

## 4.1 永远小标驱动大表（小的数据集驱动大的数据集）

```text
slect * from A where id in (select id from B)`等价于
#等价于
select id from B
select * from A where A.id=B.id
```

当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists

```text
select * from A where exists (select 1 from B where B.id=A.id)
#等价于
select * from A
select * from B where B.id = A.id`
```

当 A 表的数据集小于B表的数据集时，用 exists优于用 in

注意：A表与B表的ID字段应建立索引。

## 4.2 order by关键字优化

- order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序

- MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；

- ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列

- 尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀

- 如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序

- - 双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据
  - 单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序



- 优化策略

- - 增大sort_buffer_size参数的设置
  - 增大max_lencth_for_sort_data参数的设置

**GROUP BY关键字优化**

- group by实质是先排序后进行分组，遵照索引建的最佳左前缀
- 当无法使用索引列，增大 `max_length_for_sort_data` 参数的设置，增大`sort_buffer_size`参数的设置
- where高于having，能写在where限定的条件就不要去having限定了



















