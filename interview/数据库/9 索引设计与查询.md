# 索引设计与查询

 # 面试问题 

SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？
如何写sql能够有效的使用到复合索引？
一条sql执行过长的时间，你如何优化，从哪些方面入手？
什么是最左前缀原则？什么是最左匹配原则？ 

- 



# 三 索引设计

## 1 三星索引

2

1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2）较频繁作为查询条件的字段才去创建索引

3）更新频繁字段不适合创建索引

4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)

5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

6）定义有外键的数据列一定要建立索引。

7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8）对于定义为text、image和bit的数据类型的列不要建立索引。





# 3 索引设计

1. 单表索引数目不能超过5个

  注：聚簇索引造成的存储和查询成本当索引过多时，性能降低很快

2. 根据业务需求设计索引，如果没有查询需求，干嘛要去建索引呢

3. 一个字段的值范围很小，不要设置索引，索引不生效同事浪费插入性能

  注：当索引的值就三五个，范围很小时，数据库进行的基本是全表扫描，没必要建索引

4. 如果有幂等性需求，对需要幂等字段或字段组合，设置数据库唯一索引

5. null值对索引是一大伤害，所以不要让索引的列有null值存在

6. 尽量加索引的字段的数据类型小，也就是能用整数不用varchar能用短的varchar不用长的varchar，不要在text上设置索引

7. 一个索引包含的字段数不能超过3个

  8. 尽量在静态数据上建立索引，频繁变动数据建索引，每次db都要考虑是否重建B+树

  注：

  （1）如账户，userId设置为唯一索引，一个人只能有一个铜板账户，静态数据

  （2）收支流水表的userID设置普通索，查询效率高，查询需求

  （3）create_time 默认加索引

（4）a,b,c  组合索引，索引构建是用a+b+c进行构建的索引，如果是btree索引，查询的时候 abc|ab|a三种查询条件都会走索引，不需要对a和ab重复创建索引 ，但是 like '%b'|'%bc'|'%c'不会走索引，所以，组合索引，一定使用频率高的放在最左边  



### 

1. 全值匹配我最爱
2. 最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)
3. 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列
5. 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select
6. is null ,is not null 也无法使用索引
7. like "xxxx%" 是可以用到索引的，like "%xxxx" 则不行(like "%xxx%" 同理)。like以通配符开头('%abc...')索引失效会变成全表扫描的操作，
8. 字符串不加单引号索引失效
9. 少用or，用它来连接时会索引失效
10. <，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描

**一般性建议**

- 对于单键索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
- 少用Hint强制索引

# 4 查询优化

## 4.1 永远小标驱动大表（小的数据集驱动大的数据集）

```text
slect * from A where id in (select id from B)`等价于
#等价于
select id from B
select * from A where A.id=B.id
```

当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists

```text
select * from A where exists (select 1 from B where B.id=A.id)
#等价于
select * from A
select * from B where B.id = A.id`
```

当 A 表的数据集小于B表的数据集时，用 exists优于用 in

注意：A表与B表的ID字段应建立索引。

## 4.2 order by关键字优化

- order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序

- MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；

- ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列

- 尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀

- 如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序

- - 双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据
  - 单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序



- 优化策略

- - 增大sort_buffer_size参数的设置
  - 增大max_lencth_for_sort_data参数的设置

**GROUP BY关键字优化**

- group by实质是先排序后进行分组，遵照索引建的最佳左前缀
- 当无法使用索引列，增大 `max_length_for_sort_data` 参数的设置，增大`sort_buffer_size`参数的设置
- where高于having，能写在where限定的条件就不要去having限定了



# 未看 美团 sql优化 https://blog.csdn.net/MeituanTech/article/details/80062511#comments_14154434

















