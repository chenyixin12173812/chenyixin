# 数据库设计

# 0 集群设计

 https://www.cnblogs.com/wintersun/p/4638176.html 

 https://www.cnblogs.com/zhangchao0515/p/11493236.html 

# 0.0 mysql支持的集群方案

### **复制的基本原理**

- slave 会从 master 读取 binlog 来进行数据同步
- 三个步骤

1. master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；
2. salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;
3. slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。

![img](https://pic3.zhimg.com/80/v2-cd12a431f29aedbc2ec6cc66ff25ca96_720w.jpg)

### **复制的基本原则**

- 每个 slave只有一个 master
- 每个 salve只能有一个唯一的服务器 ID
- 每个master可以有多个salve

1 单主多从

  1个Master复制多个 Slave 的架构实施非常简单， 多个 Slave 和单个 Slave的实施
并没有实质性的区别。 在 Master 端并不 Care 有多少个 Slave 连上了自己， 只要有 Slave
的 IO 线程通过了连接认证， 向他请求指定位置之后的 Binary Log 信息， 他就会按照该IO
线程的要求  



2 双主多从 

  有些时候，简单的从一个 MySQL 复制到另外一个 MySQL 的基本 Replication 架构，
可能还会需要在一些特定的场景下进行 Master 的切换。 如在 Master 端需要进行一些特别
的维护操作的时候，可能需要停 MySQL 的服务。这时候，为了尽可能减少应用系统写服务
的停机时间，最佳的做法就是将我们的 Slave 节点切换成 Master 来提供写入的服务。  

3 联复制架构(Master - Slaves - Slaves ...)  

  在有些应用场景中，可能读写压力差别比较大，读压力特别的大，一个 Master 可能需
要上10台甚至更多的 Slave 才能够支撑注读的压力。这时候， Master 就会比较吃力了，
因为仅仅连上来的 Slave IO 线程就比较多了， 这样写的压力稍微大一点的时候，Master 端
因为复制就会消耗较多的资源，很容易造成复制的延时  

## 0.1 58同城可用性设计 

1 .复制+冗余

副作用：复制+冗余一定会引发一致性问题

保证“读”高可用的方法：复制从库，冗余数据，如下图

 [![0](https://images0.cnblogs.com/blog/15172/201507/111044087215255.png)](http://images0.cnblogs.com/blog/15172/201507/111044078939141.png) 
带来的问题：主从不一致

2 **保证“写”高可用的一般方法：双主模式，即复制主库（很多公司用单master，此时无法保证写的可用性**），冗余数据，如下图

 [![1](https://images0.cnblogs.com/blog/15172/201507/111044100027296.png)](http://images0.cnblogs.com/blog/15172/201507/111044092683155.png) 
带来的问题：双主同步key冲突，引不一致

解决方案：

a）方案一：由数据库或者业务层保证key在两个主上不冲突

b）方案二：58同城保证“写”高可用的方法：“双主”当“主从”用，不做读写分离，在“主”挂掉的情况下，“从”（其实是另外一个主），顶上，如下图

 [![2](https://images0.cnblogs.com/blog/15172/201507/111044119248209.png)](http://images0.cnblogs.com/blog/15172/201507/111044113305324.png) 
优点：读写都到主，解决了一致性问题；“双主”当“主从”用，解决了可用性问题

**（2）读性能设计：****如何扩展读性能**

最常用的方法是，建立索引

建立非常多的索引，副作用是：

a）降低了写性能

b）索引占内存多了，放在内存中的数据就少了，数据命中率就低了，IO次数就多了

但是否想到，不同的库可以建立不同的索引呢？如下图

 [![3](https://images0.cnblogs.com/blog/15172/201507/111044136112193.png)](http://images0.cnblogs.com/blog/15172/201507/111044128613822.png) 
TIPS：**不同的库可以建立不同索引**

主库只提供写，不建立索引

online从库只提供online读，建立online读索引

offline从库只提供offline读，建立offline读索引

提高读性能常见方案二，增加从库

[![4](https://images0.cnblogs.com/blog/15172/201507/111044154396836.png)](http://images0.cnblogs.com/blog/15172/201507/111044141277336.png)

上文已经提到，这种方法会引发主从不一致问题，从库越多，主从时延越长，不一致问题越严重

这种方案很常见，但58没有采用

提高读性能方案三，增加缓存

**传统缓存的用法**是：

a）发生写请求时，先淘汰缓存，再写数据库

b）发生读请求时，先读缓存，hit则返回，miss则读数据库并将数据入缓存（此时可能旧数据入缓存），如下图

 [![5](https://images0.cnblogs.com/blog/15172/201507/111044171116590.png)](http://images0.cnblogs.com/blog/15172/201507/111044163147935.png) 
带来的问题：

a）如上文所述，数据复制会引发一致性问题，由于主从延时的存在，可能引发缓存与数据库数据不一致

b）所有app业务层都要关注缓存，无法屏蔽“主+从+缓存”的复杂性

**58同城缓存使用方案**：服务+数据+缓存

 [![6](https://images0.cnblogs.com/blog/15172/201507/111044194715904.png)](http://images0.cnblogs.com/blog/15172/201507/111044180641134.png) 
好处是：

1）引入服务层屏蔽“数据库+缓存”

2）不做读写分离，读写都到主的模式，不会引发不一致

**（3）一致性设计**

**主从不一致**解决方案

方案一：引入中间件

 [![7](https://images0.cnblogs.com/blog/15172/201507/111044217997759.png)](http://images0.cnblogs.com/blog/15172/201507/111044206438446.png) 
中间件将key上的写路由到主，在一定时间范围内（主从同步完成的经验时间），该key上的读也路由到主

方案二：读写都到主

[![8](https://images0.cnblogs.com/blog/15172/201507/111044237684658.png)](http://images0.cnblogs.com/blog/15172/201507/111044224396631.png)

上文已经提到，58同城采用了这种方法，不做读写分离，不会不一致

**数据库与缓存不一致解决方案**

两次淘汰法

[![9](https://images0.cnblogs.com/blog/15172/201507/111044253779899.png)](http://images0.cnblogs.com/blog/15172/201507/111044245028799.png)

异常的读写时序，或导致旧数据入缓存，一次淘汰不够，要进行二次淘汰

a）发生写请求时，先淘汰缓存，再写数据库，额外增加一个timer，一定时间（主从同步完成的经验时间）后再次淘汰

b）发生读请求时，先读缓存，hit则返回，miss则读数据库并将数据入缓存（此时可能旧数据入缓存，但会被二次淘汰淘汰掉，最终不会引发不一致）

**（4）扩展性设计**

（4.1）58同城秒级别数据扩容

需求：原来水平切分为N个库，现在要扩充为2N个库，希望不影响服务，在秒级别完成

 [![10](https://images0.cnblogs.com/blog/15172/201507/111044266899399.png)](http://images0.cnblogs.com/blog/15172/201507/111044261744256.png) 
最开始，分为2库，0库和1库，均采用“双主当主从用”的模式保证可用性

 [![11](https://images0.cnblogs.com/blog/15172/201507/111044279558211.png)](http://images0.cnblogs.com/blog/15172/201507/111044274244541.png) 
接下来，将从库提升，并修改服务端配置，秒级完成扩库

由于是2扩4，不会存在数据迁移，原来的0库变为0库+2库，原来的1库变为1库和3库

此时损失的是数据的可用性

 [![12](https://images0.cnblogs.com/blog/15172/201507/111044311898624.png)](http://images0.cnblogs.com/blog/15172/201507/111044295184168.png) 
最后，解除旧的双主同步（0库和2库不会数据冲突），为了保证可用性增加新的双主同步，并删除掉多余的数据

这种方案可以秒级完成N库到2N库的扩容。

存在的问题：只能完成N库扩2N库的扩容（不需要数据迁移），非通用扩容方案（例如3库扩4库就无法完成）

（4.2）非指数扩容，数据库增加字段，数据迁移

[这些方法在（上）篇中都已经介绍过，此处不再冗余，有兴趣的朋友回复“同城”回看（上）篇]

方案一：追日志方案

方案二：双写方案

## 0.2 读写分离方案
方案1：应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。
特点：数据库和应用程序强耦合，数据库如果有变化还好影响主库。<2>应用程序复杂化。

方案2：利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。
特点：<1> 数据库和应用程序弱耦合。<2> 代理存在性能瓶颈和可靠性风险增加，相对可控。
常见的中间件：<1> MySQL-Proxy 

 <2> Amoeba for MySQL(原文推荐这个，没机会对比过)  

<3> mycat  

<4> DBProxy  

<5> 公有云的RDS数据库+数据库中间件，如华为云的RDS(关系型数据库)+DDM(分布式数据库中间件)

## 0.3 负载均衡

## 0.4 集群可用性探测机制

## 0.5 提供分片规则和路由策略

# 0.6 集群技术对比

 https://www.csdn.net/article/2009-06-16/2503 

**Oracle’s Real Application Cluster (我们将称之为RAC). 
Microsoft SQL Cluster Server (我们将称之为MSCS)..IBM’s [DB2](http://www.ibm.com/developerworks/cn/db2/zones/db2ii/index.html) UDB High Availability Cluster (我们将称之为UDB) Sybase ASE High Availability Cluster (我们将称之为ASE) MySQL High Availability Cluster (我们将称之为MySQL CS).Parallel Computers Technology Inc.’s ICX-UDS middleware 我们将称之为ICX). 除了ICX，所有其它的集群技术都是基于数据库引擎的。所以ICX可以支持任何当前流行的数据库**

# 1.数据库表设计

 https://blog.csdn.net/weixin_34290631/article/details/92651556?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param 

> 







# 数据库之父Codd的12条法则



另外，我们回顾一下数据库之父Codd的12条法则，作为数据库设计的指导性方针：

1. **信息法则 
   **关系数据库中的所有信息都用唯一的一种方式表示——表中的值。
2. **保证访问法则 
   **依靠表名、主键值和列名的组合，保证能访问每个数据项。
3. **空值的系统化处理 
   **支持空值（NULL），以系统化的方式处理空值，空值不依赖于数据类型。
4. **基于关系模型的动态联机目录 
   **数据库的描述应该是自描述的，在逻辑级别上和普通数据采用同样的表示方式，即数据库必须含有描述该数据库结构的系统表或者数据库描述信息应该包含在用户可以访问的表中。
5. **统一的数据子语言法则 
   **一个关系数据库系统可以支持几种语言和多种终端使用方式，但必须至少有一种语言，它的语句能够一某种定义良好的语法表示为字符串，并能全面地支持以下所有规则：数据定义、视图定义、数据操作、约束、授权以及事务。（这种语言就是SQL)
6. **视图更新法则 
   **所有理论上可以更新的视图也可以由系统更新。
7. **高级的插入、更新和删除操作 
   **把一个基础关系或派生关系作为单个操作对象处理的能力不仅适应于数据的检索，还适用于数据的插入、修改个删除，即在插入、修改和删除操作中数据行被视作集合。
8. **数据的物理独立性 
   **不管数据库的数据在存储表示或访问方式上怎么变化，应用程序和终端活动都保持着逻辑上的不变性。
9. **数据的逻辑独立性 
   **当对表做了理论上不会损害信息的改变时，应用程序和终端活动都会保持逻辑上的不变性。
10. **数据完整性的独立性 
    **专用于某个关系型数据库的完整性约束必须可以用关系数据库子语言定义，而且可以存储在数据目录中，而非程序中。
11. **分布独立性 
    **不管数据在物理是否分布式存储，或者任何时候改变分布策略，RDBMS的数据操纵子语言必须能使应用程序和终端活动保持逻辑上的不变性。
12. **非破坏性法则 
    **如果一个关系数据库系统支持某种低级（一次处理单个记录）语言，那么这个低级语言不能违反或绕过更高级语言（一次处理多个记录）规定的完整性法则或约束，即用户不能以任何方式违反数据库的约束。





